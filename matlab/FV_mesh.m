% edges(i,:) are the vertices defining the i'th edge

% ds(i) is the length of the i'th edge

% mids(i,k) is the k'th component of the midpoint of the i'th edge

% centers(i,k) is the k'th component of the circumcenter of the i'th triangle

% edge_dist(i,j) is the distance of the i'th edge to the j'th adjacent
% triangle (j=1,2)

% a_ijs(i) is the a_ij value corresponding to the 1st adjacent triangle of
% the i'th edge

% e_is(i,k) is the k'th component of the outer normal on the i'th edge
% w.r.t. the first attached triangle

% edgeAttachments(i,k) is the k'th adjacent triangle of the i'th edge
% (k=1,2)

% tr2edge(j, i) is the index of the i'th edge of the j'th triangle

% neighs(j, k) is the neighbor of the j'th triangle that is attached via
% triangle j's k'th edge as numbered in tr2edge

% areasi(j) is the reciprocal of the area (on the sphere) of the j'th
% triangle

clear
close all

depth_level = 5;

[vMat, fMat] = spheretribydepth(depth_level);
% generate triangulation. vMat: coordinates for each vertex, size =  (number of
% vertices x 3). fMat: connectivity list, indices of vertices that form a
% triangle, size = (number of triangles x 3). In our case generated by the
% package:

% Peter Gagarinov (2020). spheretri (https://www.github.com/pgagarinov/spheretri), GitHub. Retrieved February 14, 2020.

tr = triangulation(fMat, vMat);
edges = edges(tr);
neighbors = neighbors(tr);

centers = circumcenter(tr);
centers = centers./(vecnorm(centers,2,2));
ds = zeros(size(edges,1),1);
mids = zeros(size(edges,1), 3);
edgeAttachments =cell2mat(edgeAttachments(tr,edges));
edge_dist = zeros(size(edges,1),2);
a_ijs = zeros(size(edges,1),1);
e_is = zeros(size(edges,1),3);
N = size(fMat,1);
is = zeros(1,4*N);
js = zeros(1,4*N);
valcs = zeros(1,4*N);
ii = 1;
for i=1:size(edges,1)
    j1 = vMat(edges(i,1),:);
    j2 = vMat(edges(i,2),:);
    
    ds(i) = acos(j1*j2');
    
    mids(i,:) = (j1+j2)/norm(j1+j2);
    edge_dist(i,1) = acos(centers(edgeAttachments(i,1),:)*mids(i,:)');
    edge_dist(i,2) = acos(centers(edgeAttachments(i,2),:)*mids(i,:)');
    
    h_ij = edge_dist(:,1)+edge_dist(:,2);
    a_ijs = edge_dist(:,1)./(edge_dist(:,1)+edge_dist(:,2));
    
    m = mids(i,:)';
    edge = vMat(edges(i,2),:)-vMat(edges(i,1),:);
    edge = edge';
    c = centers(edgeAttachments(i,1),:)';
    e1 = cross(edge,m)*sign((m-c)'*cross(edge,m));
    e_is(i,:) = e1/norm(e1);
    
    is(ii) = edgeAttachments(i,1);
    js(ii) = edgeAttachments(i,1);
    valcs(ii) = -ds(i)/h_ij(i);
    ii = ii+1;
    
    is(ii) = edgeAttachments(i,2);
    js(ii) = edgeAttachments(i,2);
    valcs(ii) = -ds(i)/h_ij(i);
    ii = ii+1;
    
    is(ii) = edgeAttachments(i,1);
    js(ii) = edgeAttachments(i,2);
    valcs(ii) = ds(i)/h_ij(i);
    ii = ii+1;
    
    is(ii) = edgeAttachments(i,2);
    js(ii) = edgeAttachments(i,1);
    valcs(ii) = ds(i)/h_ij(i);
    ii = ii+1;
end

C = sparse(is,js,valcs);

tr2edge = zeros(size(fMat,1),3);
flow_signs_temp = [ones(size(edgeAttachments,1),1),-ones(size(edgeAttachments,1),1) ];
flow_signs = zeros(size(fMat,1),3);
for i=1:size(edges,1)
    for j=1:2
        if tr2edge(edgeAttachments(i,j),1)==0
            tr2edge(edgeAttachments(i,j),1) = i;
        elseif tr2edge(edgeAttachments(i,j),2)==0
            tr2edge(edgeAttachments(i,j),2) = i;
        elseif tr2edge(edgeAttachments(i,j),3)==0
            tr2edge(edgeAttachments(i,j),3) = i;
        else
            warning('FAIL')
        end
        if flow_signs(edgeAttachments(i,j),1)==0
            flow_signs(edgeAttachments(i,j),1) = flow_signs_temp(i,j);
        elseif flow_signs(edgeAttachments(i,j),2)==0
            flow_signs(edgeAttachments(i,j),2) = flow_signs_temp(i,j);
        elseif flow_signs(edgeAttachments(i,j),3)==0
            flow_signs(edgeAttachments(i,j),3) = flow_signs_temp(i,j);
        else
            warning('FAIL')
        end
    end
end

areas = zeros(1,N);
for i=1:N
    a = ds(tr2edge(i,1));
    b = ds(tr2edge(i,2));
    c = ds(tr2edge(i,3));
    
    alpha = acos((cos(a)-cos(b)*cos(c))/(sin(b)*sin(c)));
    beta = acos((cos(b)-cos(c)*cos(a))/(sin(c)*sin(a)));
    gamma = acos((cos(c)-cos(a)*cos(b))/(sin(a)*sin(b)));
    
    areas(i) = alpha+beta+gamma-pi;
end
neighs = zeros(size(neighbors));
for i=1:size(neighbors,1)
    atts1 = edgeAttachments(tr2edge(i,1),:);
    if atts1(1)==i
        att1 = atts1(2);
    else
        att1 = atts1(1);
    end
    atts2 = edgeAttachments(tr2edge(i,2),:);
    if atts2(1)==i
        att2 = atts2(2);
    else
        att2 = atts2(1);
    end
    atts3 = edgeAttachments(tr2edge(i,3),:);
    if atts3(1)==i
        att3 = atts3(2);
    else
        att3 = atts3(1);
    end
    neighs(i,:) = [att1,att2,att3];
    
end

tr2edge = [tr2edge(:,1);tr2edge(:,2);tr2edge(:,3)];
flow_signs = [flow_signs(:,1);flow_signs(:,2);flow_signs(:,3)];
aijsnew = zeros(size(tr2edge,1),1);
for i=1:length(flow_signs)
    if flow_signs(i)==1
        aijsnew(i) = a_ijs(tr2edge(i));
    else
        aijsnew(i) = 1-a_ijs(tr2edge(i));
    end
end
a_ijs = aijsnew;
mids = mids';
e_is = e_is';

iis = [sub2ind(size(C),1:size(C,1),1:size(C,2)),sub2ind(size(C),...
    [1:length(neighs(:))/3,1:length(neighs(:))/3,1:length(neighs(:))/3], ...
    neighs(:)')];

iisnew = zeros(size(iis));
iisnew(1:4:end-3) = iis(1:end/4);
iisnew(2:4:end-2) = iis(end/4+1:end/2);
iisnew(3:4:end-1) = iis(end/2+1:3*end/4);
iisnew(4:4:end) = iis(3*end/4+1:end);
iis = iisnew;

valcs = full(C(iis));
areasi = 1./areas';
areasidil = [areasi; areasi; areasi];

clear a alpha aijsnew att1 att2 att3 atts1 atts2 atts3 b beta c e1 edge flow_signs_temp gamma h_ij i ii iisnew j j1 j2 m neighbors

clear tr

tr.a_ijs = a_ijs;
tr.areas = areas;
tr.areasi = areasi;
tr.areasidil = areasidil;
tr.C = C;
tr.centers = centers;
tr.ds = ds;
tr.depth_level = depth_level;
tr.e_is = e_is;
tr.edge_dist = edge_dist;
tr.edgeAttachments = edgeAttachments;
tr.edges = edges;
tr.flow_signs = flow_signs;
tr.fMat = fMat;
tr.iis = iis;
tr.is = is;
tr.js = js;
tr.mids = mids;
tr.neighs = neighs;
tr.tr2edge = tr2edge;
tr.valcs = valcs;
tr.vMat = vMat;

save('FV_meshes/mesh_5.mat','tr');
