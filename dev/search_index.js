var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"In the following, you find the documentation of some, and hopefully soon all, exported functions of MNPDynamics.jl:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Modules = [MNPDynamics]","category":"page"},{"location":"api.html#MNPDynamics.simulationMNP-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T","page":"API","title":"MNPDynamics.simulationMNP","text":"simulationMNP(B::Matrix{T}, t; kargs...)\n\nThis version takes the fields in discretized form\n\n\n\n\n\n","category":"method"},{"location":"api.html#MNPDynamics.simulationMNP-Union{Tuple{g}, Tuple{g, Any}} where g","page":"API","title":"MNPDynamics.simulationMNP","text":"simulationMNP(B, t, offsets; kargs...) \n\n\n\n\n\n","category":"method"},{"location":"api.html#MNPDynamics.simulationMNPMultiParams-Union{Tuple{P}, Tuple{G}, Tuple{G, Any, Vector{P}}} where {G, P}","page":"API","title":"MNPDynamics.simulationMNPMultiParams","text":"simulationMNPMultiParams(B, t, params; kargs...) \n\n\n\n\n\n","category":"method"},{"location":"api.html#MNPDynamics.simulationMNPMultiParams-Union{Tuple{T}, Tuple{Array{T, 3}, Any}} where T","page":"API","title":"MNPDynamics.simulationMNPMultiParams","text":"simulationMNPMultiParams(B::Vector{Matrix{T}}, t; kargs...) \n\nThis version takes the fields in discretized form\n\n\n\n\n\n","category":"method"},{"location":"overview.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"On this page we give an overview of MNPDynamics. ","category":"page"},{"location":"overview.html#Simple-Simulation-(No-Relaxation)","page":"Overview","title":"Simple Simulation (No Relaxation)","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"We start with a very simple simulation. 20 nm particles are simulated without relaxation under sinusoidal excitation. We start by loading MNPDynamics and define the time interval. Here we use 1000 samples and an excitation frequency of 25 kHz:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"using MNPDynamics\n\n# Time parameters\nfx = 25000;\ntLength = 1000;       # length of time vector\ntMax = 1/fx;          # maximum evaluation time in seconds\nt = range(0, stop=tMax, length=tLength);","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"In the next step we define the applied magnetic field. This is done using by defining a  magnetic field function B that maps t to the magnetic flux density B:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"# Field parameters\namplitude = 0.012\n\n# Magnetic field for simulation \nB(t) = amplitude*[cos(2*pi*fx*t), 0, 0]","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"You can of course also define this as","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"function B(t)\n return amplitude*[cos(2*pi*fx*t), 0, 0]\nend","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"or as an anonymous function:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"B = t -> (amplitude*[cos(2*pi*fx*t), 0, 0])","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"You also don't need to call it B.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"In the next step we define additional simulation parameters in a dictionary p and pass B, t and p to the function simulationMNP:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"# Parameters\np = Dict{Symbol,Any}()\np[:DCore] = 20e-9                  # particle diameter in nm\np[:relaxation] = NO_RELAXATION     # relaxation mode\n\n# Do simulation\nm = simulationMNP(B, t; p...)","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"What you get back is the mean magnetic moment of the particle. Often we measure this function inductively using a pick-up coil and then receive the time derivative of the mean magnetic moment. The following image shows the result of this simple simulation.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"(Image: Simple 1D Simulation)","category":"page"},{"location":"overview.html#Neel-Relaxation","page":"Overview","title":"Neel Relaxation","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"We next repeat the simulation but change the parameter dictionary like this:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"p = Dict{Symbol,Any}()\np[:DCore] = 20e-9         # particle diameter in nm\np[:α] = 0.1               # damping coefficient\np[:kAnis] = 11000         # anisotropy constant\np[:N] = 20                # maximum spherical harmonics index to be considered\np[:n] = [1;0;0]           # anisotropy axis\np[:relaxation] = NEEL     # relaxation mode\np[:reltol] = 1e-6         # relative tolerance\np[:abstol] = 1e-6         # absolute tolerance\np[:tWarmup] = 0.00005     # warmup time. The simulation is started at -tWarmup","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"The results in the following images show that the particle response now clearly lacks behind the excitation:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"(Image: 1D Neel Relaxation)","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Next, we switch the excitation function to be rect function.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Brect(t) = amplitude*[ 0.25 < fx*mod(t,1) < 0.75  ? -1.0 : 1.0 , 0, 0]","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"We also use a more stable solver:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"p[:solver] = :Rodas5","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"The simulation result looks like this:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"(Image: 1D Neel Relaxation)","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"One can nicely see the expected exponential decay after the field changes its sign.","category":"page"},{"location":"overview.html#Brown-Relaxation","page":"Overview","title":"Brown Relaxation","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"It is also possible to simulate Brownian relaxation. This can be done with the  following parameter dictionary:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"# Parameters\np = Dict{Symbol,Any}()\np[:DCore] = 20e-9         # particle diameter in nm\np[:DHydro] = 80e-9        # particle diameter in nm\np[:η] = 1e-5              # viscosity\np[:N] = 20                # maximum spherical harmonics index to be considered\np[:relaxation] = BROWN    # relaxation mode","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"(Image: 1D Brown Relaxation)","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"note: Note\nCurrently it is not possible to simulate Brownian and Neel relaxation simultaneously.","category":"page"},{"location":"overview.html#Hysteresis-Loops","page":"Overview","title":"Hysteresis Loops","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"The following example shows hysteresis loops for different excitation amplitudes and Brownian and Neel relaxation.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"(Image: Hysteresis)","category":"page"},{"location":"overview.html#Multiple-Parameters","page":"Overview","title":"Multiple Parameters","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Quite often, the goal is to to perform multiple simulations. Since this can get quite time intensive it can be benefitial to use parallel computation. To do this you need to start julia with -p P where P is the number of CPU cores that the computer has.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Our goal is to perform simulations with the same 2D excitation but for various different static offset fields. In the magnetic particle imaging (MPI) setting this is usually referred to as the system matrix. In particular we aim to reproduce Fig. 4 of this publication.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"We start by defining the general parameters:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"using MNPDynamics, FFTW\n\n# Parameters\np = Dict{Symbol,Any}()\np[:DCore] = 20e-9         # particle diameter in nm\np[:α] = 0.1               # damping coefficient\np[:kAnis] = 1250          # anisotropy constant\np[:N] = 20                # maximum spherical harmonics index to be considered\np[:relaxation] = NEEL     # relaxation mode\np[:reltol] = 1e-4         # relative tolerance\np[:abstol] = 1e-6         # absolute tolerance\np[:tWarmup] = 0.00005     # warmup time\np[:derivative] = true\np[:solver] = :FBDF        # Use more stable solver\n\n# Excitation frequencies\nconst fx = 2.5e6 / 102\nconst fy = 2.5e6 / 96\n\nsamplingRate = 2.5e6\ntLength = lcm(96,102);             # length of time vector\ntMax = lcm(96,102) / samplingRate; # maximum evaluation time in seconds\nt = range(0, stop=tMax, length=tLength);","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Next we define a more general magnetic field function, which not only gets the time t but also the offset.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"const amplitude = 0.012\nB(t, offset) = amplitude*[sin(2*pi*fx*t), sin(2*pi*fy*t), 0] .+ offset ","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"We then define the offset on a 30 x 30 grid. This can be done in Julia in a very terse syntax using CartesianIndices:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"nOffsets = (30, 30, 1)\n\noversampling = 1.25\noffsets = vec([ oversampling*amplitude.*2.0.*((Tuple(x).-0.5)./nOffsets.-0.5)  \n                for x in CartesianIndices(nOffsets) ])","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Basically, offsets is a vector of Tuples and the elements are passed to the callback function B we defined before.","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"In addition to the offsets we also want the anisotropy axis to be offset dependent (see publication). Therefore, we define the anisotropy axis on a grid as well: ","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"anisotropyAxis = vec([ oversampling*2.0.*((Tuple(x).-0.5)./nOffsets.-0.5) \n                       for x in CartesianIndices(nOffsets) ])\np[:kAnis] = p[:kAnis]*anisotropyAxis","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"Finally we perform the simulation and apply a Fourier transform along the time axis:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"smM = simulationMNPMultiParams(B, t, offsets; p...)\n\nsmMFT = reshape(rfft(smM, 1), :, 3, nOffsets...)","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"The resulting dataset looks like this:","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"(Image: 2D System Matrix)","category":"page"},{"location":"index.html#MNPDynamics","page":"Home","title":"MNPDynamics","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Julia package for the simulation of Magnetic Nanoparticle Dynamics","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package provides Julia based implementation of a Fokker-Plank based magnetic particle simulation and allows to model Brownian or Néel rotation. It is based on the Matlab package MNPDynamics and implements the discretization using spherical harmonics. For details on the mathematical background be refer to this paper.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"add https://github.com/MagneticParticleImaging/MNPDynamics.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will install the packages MNPDynamics.jl and all its dependencies. ","category":"page"},{"location":"index.html#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project. You can do so by citing the publication","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"H. Albers, T. Kluth, and T. Knopp, Simulating magnetization dynamics of large ensembles of single domain nanoparticles: Numerical study of Brown/Néel dynamics and parameter identification problems in magnetic particle imaging, Journal of Magnetism and Magnetic Materials, 541, 168508, 2022, link, arXiv:2010.07772","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A BibTeX file MNPDynamics.bib can be found in the root folder of the Github repository.","category":"page"},{"location":"index.html#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you have problems using the software, find bugs or have ideas for improvements please use the issue tracker. For general questions please use the discussions section on Github.","category":"page"},{"location":"index.html#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tobias Knopp\nHannes Albers\nTobias Kluth\nMarco Maass\nMartin Möddel","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A complete list of contributors can be found on the Github page.","category":"page"}]
}
